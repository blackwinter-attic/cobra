.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AI::Categorizer::KnowledgeSet 3"
.TH AI::Categorizer::KnowledgeSet 3 "2006-06-25" "perl v5.8.1" "User Contributed Perl Documentation"
.SH "NAME"
AI::Categorizer::KnowledgeSet \- Encapsulates set of documents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use AI::Categorizer::KnowledgeSet;
\& my $k = new AI::Categorizer::KnowledgeSet(...parameters...);
\& my $nb = new AI::Categorizer::Learner::NaiveBayes(...parameters...);
\& $nb->train(knowledge_set => $k);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The KnowledgeSet class that provides an interface to a set of
documents, a set of categories, and a mapping between the two.  Many
parameters for controlling the processing of documents are managed by
the KnowledgeSet class.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Creates a new KnowledgeSet and returns it.  Accepts the following
parameters:
.RS 4
.IP "load" 4
.IX Item "load"
If a \f(CW\*(C`load\*(C'\fR parameter is present, the \f(CW\*(C`load()\*(C'\fR method will be
invoked immediately.  If the \f(CW\*(C`load\*(C'\fR parameter is a string, it will be
passed as the \f(CW\*(C`path\*(C'\fR parameter to \f(CW\*(C`load()\*(C'\fR.  If the \f(CW\*(C`load\*(C'\fR
parameter is a hash reference, it will represent all the parameters to
pass to \f(CW\*(C`load()\*(C'\fR.
.IP "categories" 4
.IX Item "categories"
An optional reference to an array of Category objects representing the
complete set of categories in a KnowledgeSet.  If used, the
\&\f(CW\*(C`documents\*(C'\fR parameter should also be specified.
.IP "documents" 4
.IX Item "documents"
An optional reference to an array of Document objects representing the
complete set of documents in a KnowledgeSet.  If used, the
\&\f(CW\*(C`categories\*(C'\fR parameter should also be specified.
.IP "features_kept" 4
.IX Item "features_kept"
A number indicating how many features (words) should be considered
when training the Learner or categorizing new documents.  May be
specified as a positive integer (e.g. 2000) indicating the absolute
number of features to be kept, or as a decimal between 0 and 1
(e.g. 0.2) indicating the fraction of the total number of features to
be kept, or as 0 to indicate that no feature selection should be done
and that the entire set of features should be used.  The default is
0.2.
.IP "feature_selection" 4
.IX Item "feature_selection"
A string indicating the type of feature selection that should be
performed.  Currently the only option is also the default option:
\&\f(CW\*(C`document_frequency\*(C'\fR.
.IP "tfidf_weighting" 4
.IX Item "tfidf_weighting"
Specifies how document word counts should be converted to vector
values.  Uses the three-character specification strings from Salton &
Buckley's paper \*(L"Term\-weighting approaches in automatic text
retrieval\*(R".  The three characters indicate the three factors that will
be multiplied for each feature to find the final vector value for that
feature.  The default weighting is \f(CW\*(C`xxx\*(C'\fR.
.Sp
The first character specifies the \*(L"term frequency\*(R" component, which
can take the following values:
.RS 4
.IP "b" 4
.IX Item "b"
Binary weighting \- 1 for terms present in a document, 0 for terms absent.
.IP "t" 4
.IX Item "t"
Raw term frequency \- equal to the number of times a feature occurs in
the document.
.IP "x" 4
.IX Item "x"
A synonym for 't'.
.IP "n" 4
.IX Item "n"
Normalized term frequency \- 0.5 + 0.5 * t/max(t).  This is the same as
the 't' specification, but with term frequency normalized to lie
between 0.5 and 1.
.RE
.RS 4
.Sp
The second character specifies the \*(L"collection frequency\*(R" component, which
can take the following values:
.IP "f" 4
.IX Item "f"
Inverse document frequency \- multiply term \f(CW\*(C`t\*(C'\fR's value by \f(CW\*(C`log(N/n)\*(C'\fR,
where \f(CW\*(C`N\*(C'\fR is the total number of documents in the collection, and
\&\f(CW\*(C`n\*(C'\fR is the number of documents in which term \f(CW\*(C`t\*(C'\fR is found.
.IP "p" 4
.IX Item "p"
Probabilistic inverse document frequency \- multiply term \f(CW\*(C`t\*(C'\fR's value
by \f(CW\*(C`log((N\-n)/n)\*(C'\fR (same variable meanings as above).
.IP "x" 4
.IX Item "x"
No change \- multiply by 1.
.RE
.RS 4
.Sp
The third character specifies the \*(L"normalization\*(R" component, which
can take the following values:
.IP "c" 4
.IX Item "c"
Apply cosine normalization \- multiply by 1/length(document_vector).
.IP "x" 4
.IX Item "x"
No change \- multiply by 1.
.RE
.RS 4
.Sp
The three components may alternatively be specified by the
\&\f(CW\*(C`term_weighting\*(C'\fR, \f(CW\*(C`collection_weighting\*(C'\fR, and \f(CW\*(C`normalize_weighting\*(C'\fR
parameters respectively.
.RE
.IP "verbose" 4
.IX Item "verbose"
If set to a true value, some status/debugging information will be
output on \f(CW\*(C`STDOUT\*(C'\fR.
.RE
.RS 4
.RE
.IP "\fIcategories()\fR" 4
.IX Item "categories()"
In a list context returns a list of all Category objects in this
KnowledgeSet.  In a scalar context returns the number of such objects.
.IP "\fIdocuments()\fR" 4
.IX Item "documents()"
In a list context returns a list of all Document objects in this
KnowledgeSet.  In a scalar context returns the number of such objects.
.IP "\fIdocument()\fR" 4
.IX Item "document()"
Given a document name, returns the Document object with that name, or
\&\f(CW\*(C`undef\*(C'\fR if no such Document object exists in this KnowledgeSet.
.IP "\fIfeatures()\fR" 4
.IX Item "features()"
Returns a FeatureSet object which represents the features of all the
documents in this KnowledgeSet.
.IP "\fIverbose()\fR" 4
.IX Item "verbose()"
Returns the \f(CW\*(C`verbose\*(C'\fR parameter of this KnowledgeSet, or sets it with
an optional argument.
.IP "\fIscan_stats()\fR" 4
.IX Item "scan_stats()"
Scans all the documents of a Collection and returns a hash reference
containing several statistics about the Collection.  (\s-1XXX\s0 need to describe stats)
.IP "\fIscan_features()\fR" 4
.IX Item "scan_features()"
This method scans through a Collection object and determines the
\&\*(L"best\*(R" features (words) to use when loading the documents and training
the Learner.  This process is known as \*(L"feature selection\*(R", and it's a
very important part of categorization.
.Sp
The Collection object should be specified as a \f(CW\*(C`collection\*(C'\fR parameter,
or by giving the arguments to pass to the Collection's \f(CW\*(C`new()\*(C'\fR method.
.Sp
The process of feature selection is governed by the
\&\f(CW\*(C`feature_selection\*(C'\fR and \f(CW\*(C`features_kept\*(C'\fR parameters given to the
KnowledgeSet's \f(CW\*(C`new()\*(C'\fR method.
.Sp
This method returns the features as a FeatureVector whose values are
the \*(L"quality\*(R" of each feature, by whatever measure the
\&\f(CW\*(C`feature_selection\*(C'\fR parameter specifies.  Normally you won't need to
use the return value, because this FeatureVector will become the
\&\f(CW\*(C`use_features\*(C'\fR parameter of any Document objects created by this
KnowledgeSet.
.IP "\fIsave_features()\fR" 4
.IX Item "save_features()"
Given the name of a file, this method writes the features (as
determined by the \f(CW\*(C`scan_features\*(C'\fR method) to the file.
.IP "\fIrestore_features()\fR" 4
.IX Item "restore_features()"
Given the name of a file written by \f(CW\*(C`save_features\*(C'\fR, loads the
features from that file and passes them as the \f(CW\*(C`use_features\*(C'\fR
parameter for any Document objects created in the future by this
KnowledgeSet.
.IP "\fIread()\fR" 4
.IX Item "read()"
Iterates through a Collection of documents and adds them to the
KnowledgeSet.  The Collection can be specified using a \f(CW\*(C`collection\*(C'\fR
parameter \- otherwise, specify the arguments to pass to the \f(CW\*(C`new()\*(C'\fR
method of the Collection class.
.IP "\fIload()\fR" 4
.IX Item "load()"
This method can do feature selection and load a Collection in one step
(though it currently uses two steps internally).  
.IP "\fIadd_document()\fR" 4
.IX Item "add_document()"
Given a Document object as an argument, this method will add it and
any categories it belongs to to the KnowledgeSet.
.IP "\fImake_document()\fR" 4
.IX Item "make_document()"
This method will create a Document object with the given data and then
call \f(CW\*(C`add_document()\*(C'\fR to add it to the KnowledgeSet.  A \f(CW\*(C`categories\*(C'\fR
parameter should specify an array reference containing a list of
categories \fIby name\fR.  These are the categories that the document
belongs to.  Any other parameters will be passed to the Document
class's \f(CW\*(C`new()\*(C'\fR method.
.IP "\fIfinish()\fR" 4
.IX Item "finish()"
This method will be called prior to training the Learner.  Its purpose
is to perform any operations (such as feature vector weighting) that
may require examination of the entire KnowledgeSet.
.IP "\fIweigh_features()\fR" 4
.IX Item "weigh_features()"
This method will be called during \f(CW\*(C`finish()\*(C'\fR to adjust the weights of
the features according to the \f(CW\*(C`tfidf_weighting\*(C'\fR parameter.
.IP "\fIdocument_frequency()\fR" 4
.IX Item "document_frequency()"
Given a single feature (word) as an argument, this method will return
the number of documents in the KnowledgeSet that contain that feature.
.IP "\fIpartition()\fR" 4
.IX Item "partition()"
Divides the KnowledgeSet into several subsets.  This may be useful for
performing cross\-validation.  The relative sizes of the subsets should
be passed as arguments.  For example, to split the KnowledgeSet into
four KnowledgeSets of equal size, pass the arguments .25, .25, .25
(the final size is 1 minus the sum of the other sizes).  The
partitions will be returned as a list.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, ken@mathforum.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2003 Ken Williams.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIAI::Categorizer\fR\|(3)
